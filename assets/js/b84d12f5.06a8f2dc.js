"use strict";(self.webpackChunkpipecat_docs=self.webpackChunkpipecat_docs||[]).push([[6767],{8691:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var s=n(4848),a=n(8453);const i={sidebar_position:1},o="The Architecture of Pipecat",r={id:"understanding-bots/dailyai-architecture",title:"The Architecture of Pipecat",description:'pipecat is a framework for building real-time, multimodal AI apps. "Multimodal" means you can use any combination of audio, video, images, and/or text in your interactions. And "real-time" means that things are happening quickly enough that it feels conversational\u2014a "back-and-forth" with a bot, not submitting a query and waiting for results.',source:"@site/docs/understanding-bots/dailyai-architecture.md",sourceDirName:"understanding-bots",slug:"/understanding-bots/dailyai-architecture",permalink:"/docs/understanding-bots/dailyai-architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/understanding-bots/dailyai-architecture.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Understanding Bots",permalink:"/docs/category/understanding-bots"},next:{title:"From Theory to Practice: A Simplified Bot",permalink:"/docs/understanding-bots/from-theory-to-practice"}},c={},h=[];function d(e){const t={code:"code",em:"em",h1:"h1",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"the-architecture-of-pipecat",children:"The Architecture of Pipecat"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pipecat"}),' is a framework for building real-time, multimodal AI apps. "Multimodal" means you can use any combination of audio, video, images, and/or text in your interactions. And "real-time" means that things are happening quickly enough that it feels conversational\u2014a "back-and-forth" with a bot, not submitting a query and waiting for results.']}),"\n",(0,s.jsxs)(t.p,{children:["To understand this, let's look at an example of talking to an LLM-powered chatbot. Here's a video of a conversation with the ",(0,s.jsx)(t.code,{children:"chatbot"})," example app:"]}),"\n",(0,s.jsx)(t.p,{children:"(storybot video)"}),"\n",(0,s.jsx)(t.p,{children:"The flow of the interactions is pretty straightforward:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"The bot says something."}),"\n",(0,s.jsx)(t.li,{children:"The user says something."}),"\n",(0,s.jsx)(t.li,{children:"The bot says something."}),"\n",(0,s.jsx)(t.li,{children:"The user says something."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Reapeat until the user gets bored."}),"\n",(0,s.jsx)(t.p,{children:"Let's look at those interactions from the bot's perspective. Every time the user says something, the bot needs to do several things to say something back:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Transcribe and collect all of the user's speech until they stop talking."}),"\n",(0,s.jsxs)(t.li,{children:["Add whatever the user said into a ",(0,s.jsx)(t.code,{children:"context"})," object."]}),"\n",(0,s.jsx)(t.li,{children:"Send the entire context to an LLM."}),"\n",(0,s.jsx)(t.li,{children:"Collect the full response from the LLM (and add it to the saved context as well)."}),"\n",(0,s.jsx)(t.li,{children:'"Speak" the LLM\'s response as audio data using a text-to-speech service'}),"\n",(0,s.jsx)(t.li,{children:"Play the audio so the user can hear it"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"To do this in real time, we still need to do all the same things, but we need to change the order in which they happen. If you've used ChatGPT, you've seen the way it updates one word at a time, almost like a human typing really fast. The API can return completions in the same way\u2014it's called a \"streaming response\"."}),"\n",(0,s.jsx)(t.p,{children:"Instead of waiting for the entire LLM response, we can watch the text come in a word at a time. As soon as we have the words for the first sentence of the bot's response, we can start generating the speech for that sentence. Meanwhile, we can keep accumulating LLM response text until we have the text for the second sentence, then start text-to-speech for that page, and so on."}),"\n",(0,s.jsx)(t.p,{children:"We can start playing back the first stentence's audio for the user as soon as it's done generating. And as long as we can generate the audio for the next sentence before the first sentence finishes playback, it will feel totally seamless."}),"\n",(0,s.jsx)(t.p,{children:"The diagram for this approach looks like this:"}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Basic pipeline image",src:n(1652).A+""})})}),"\n",(0,s.jsxs)(t.p,{children:["This structure is sometimes called a ",(0,s.jsx)(t.em,{children:"data processing pipeline"}),", or just 'pipeline' for short. It's a fundamental part of how ",(0,s.jsx)(t.code,{children:"pipecat"})," apps work. Here's a diagram showing the architecture of ",(0,s.jsx)(t.code,{children:"pipecat"})," apps:"]}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Pipecat Architecture",src:n(4677).A+""})})}),"\n",(0,s.jsx)(t.p,{children:"There are four important terms in that diagram to define."}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"frame"})," is a container for different data types. They're the fundamental unit of data that moves through a ",(0,s.jsx)(t.code,{children:"pipecat"})," app. There are frame types for text data, images, and audio. But there are many others, like LLM context frames, sprite animation frames, transcription frames, and more."]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"service"})," processes the stream of frames moving through the pipeline in some way. A service takes each frame that comes in to its input and decides whether to pass it along to the next service, modify it in some way, or consume it and possibly generate some other kind of output frame(s). For example, a text-to-speech service only cares about text frames; it will forward along all other frames, but it will consume text frames, generate speech, and emit that speech as audio frames. An LLM service will consume an LLM context frame (with a list of ",(0,s.jsx)(t.code,{children:"user"})," and ",(0,s.jsx)(t.code,{children:"assistant"}),' messages) and emit a bunch of text frames. A "logger" service might forward along all types of frames, but log them to the console as it forwards them. One important convention to reiterate: ',(0,s.jsx)(t.em,{children:"services should just pass along frames that they don't do anything with."})]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.strong,{children:"pipeline"}),", then, connects services together to move frames between them. Most pipelines are fairly simple and linear: ",(0,s.jsx)(t.code,{children:"LLM -> TTS"})," for example. But the pipeline also enables some pretty complex workflows, like generating audio and images in parallel, but ensuring the resulting frames stay together."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"transport"})," is what connects the pipeline to the bot's I/O. We sometimes call it 'the gateway to the real world'. The transport can receive transcribed user speech, or webcam frames, or other types of input, and send that input into the pipeline as different frame types. Likewise, the output of the pipeline connects to the transport so that audio, video, and/or image frames turn into pictures that the user sees and audio that they hear."]}),"\n",(0,s.jsx)(t.p,{children:"Let's see how these concepts map to actual bot code in the next section."})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1652:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/basic-pipeline-717bfcc51d0e2b982afbdaf4e75aa03f.svg"},4677:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/pipecat-architecture-c668311911ec4b1f27006defea2a2b7f.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);