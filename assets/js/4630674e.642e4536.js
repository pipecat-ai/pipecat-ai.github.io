"use strict";(self.webpackChunkpipecat_docs=self.webpackChunkpipecat_docs||[]).push([[304],{8824:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var r=t(4848),s=t(8453);const i={},o="DailyTransport",a={id:"api-reference/transports/daily-transport",title:"DailyTransport",description:"The DailyTransport is a full-featured transport that enables you to join Pipecat bots to Daily WebRTC video calls. It's built on top of daily-python, and it gives you access to a lot of advanced features\u2014but it's also a great way to simply use WebRTC as the media backbone for building real-time bot interactions.",source:"@site/docs/api-reference/transports/daily-transport.md",sourceDirName:"api-reference/transports",slug:"/api-reference/transports/daily-transport",permalink:"/docs/api-reference/transports/daily-transport",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-reference/transports/daily-transport.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Transports",permalink:"/docs/category/transports"},next:{title:"LocalTransport",permalink:"/docs/api-reference/transports/local-transport"}},l={},d=[{value:"DailyTransport.new()",id:"dailytransportnew",level:2},{value:"A bit more about VAD",id:"a-bit-more-about-vad",level:3},{value:"Event Handlers",id:"event-handlers",level:2},{value:"Send and receive behavior",id:"send-and-receive-behavior",level:2},{value:"transport.run()",id:"transportrun",level:3},{value:"transport.run_pipeline()",id:"transportrun_pipeline",level:3},{value:"transport.run_interruptible_pipeline()",id:"transportrun_interruptible_pipeline",level:3},{value:"Instance Methods",id:"instance-methods",level:2},{value:"<code>send_app_message</code>",id:"send_app_message",level:3},{value:"<code>dialout</code>",id:"dialout",level:3},{value:"<code>start_recording</code>",id:"start_recording",level:3},{value:"<code>say</code>",id:"say",level:3},{value:"<code>stop</code> and <code>stop_when_done</code>",id:"stop-and-stop_when_done",level:3},{value:"Frame Behaviors",id:"frame-behaviors",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"dailytransport",children:"DailyTransport"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"DailyTransport"})," is a full-featured transport that enables you to join Pipecat bots to Daily WebRTC video calls. It's built on top of ",(0,r.jsx)(n.a,{href:"https://docs.daily.co/reference/daily-python",children:"daily-python"}),", and it gives you access to a lot of advanced features\u2014but it's also a great way to simply use WebRTC as the media backbone for building real-time bot interactions."]}),"\n",(0,r.jsx)(n.h2,{id:"dailytransportnew",children:"DailyTransport.new()"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DailyTransport.new(\n    room_url: str,\n    token: str | None,\n    bot_name: str,\n    min_others_count: int = 1,\n    start_transcription: bool = False,\n    **kwargs\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Positional arguments (but it's probably better to call them by name):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"room_url"}),": The Daily room URL to connect to. It looks like ",(0,r.jsx)(n.code,{children:"https://YOURDOMAIN.daily.co/YOURROOM"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"token"}),": You'll usually want to connect the bot to the room with owner privileges. If so, you can Daily's REST API to ",(0,r.jsx)(n.a,{href:"https://docs.daily.co/reference/rest-api/meeting-tokens",children:"create a meeting token"}),", and include that token string here."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"bot_name"}),": You'll see the bot's name if you use Daily Prebuilt, for example."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"min_others_count"}),": After someone else joins, when the number of other participants in the room drops back below this number, the bot will exit. set this to 0 disable the bot automatically leaving the room."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"start_transcription"}),": If you want to receive ",(0,r.jsx)(n.code,{children:"TranscriptionFrame"}),"s, you'll need to set this to True. ",(0,r.jsxs)(n.strong,{children:["This requires an owner token to be included in the ",(0,r.jsx)(n.code,{children:"token"})," property."]})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Other available keyword arguments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vad_enabled"}),": Whether or not to use Voice Activity Detection (VAD). If ",(0,r.jsx)(n.code,{children:"True"}),", the transport will emit ",(0,r.jsx)(n.code,{children:"UserStartedSpeaking"})," and ",(0,r.jsx)(n.code,{children:"UserStoppedSpeaking"})," frames. VAD is also necessary for interruptions support. Defaults to ",(0,r.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vad_start_s"}),": The amount of time a user needs to speak before the transport emits a ",(0,r.jsx)(n.code,{children:"UserStartedSpeaking"})," frame. Defaults to ",(0,r.jsx)(n.code,{children:"0.2"}),", or 200ms."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vad_stop_s"}),": The amount of time a user needs to stop speaking and remain silent before the transport emits a ",(0,r.jsx)(n.code,{children:"UserStoppedSpeaking"})," frame. Defaults to ",(0,r.jsx)(n.code,{children:"0.8"}),", or 800ms. This value represents a good middle ground: It's short enough that conversation feels responsive, but long enough that Deepgram can usually return all the transcriptions before the ",(0,r.jsx)(n.code,{children:"UserStoppedSpeaking"})," frame is emitted."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"a-bit-more-about-vad",children:"A bit more about VAD"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"DailyTransport"})," can use the VAD support built into the WebRTC library with no additional dependencies. However, we recommend installing the optional ",(0,r.jsx)(n.code,{children:"silero"})," dependency if your platform supports it. This is an AI VAD library powered by Torch, and it's generally a bit better at distinguising talking from background noise. Pipecat will automatically use Silero VAD if you've installed the dependencies."]}),"\n",(0,r.jsx)(n.h2,{id:"event-handlers",children:"Event Handlers"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"add_event_handler"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"participant_joined"}),"\n",(0,r.jsx)(n.code,{children:"first_other_participant_joined"}),"\n",(0,r.jsx)(n.code,{children:"participant_left"}),"\n",(0,r.jsx)(n.code,{children:"transcription_message"}),"\n",(0,r.jsx)(n.code,{children:"app_message"})]}),"\n",(0,r.jsx)(n.p,{children:"Other transcription events"}),"\n",(0,r.jsx)(n.h2,{id:"send-and-receive-behavior",children:"Send and receive behavior"}),"\n",(0,r.jsx)(n.h3,{id:"transportrun",children:"transport.run()"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"transport.run(pipeline: Pipeline | None = None, override_pipeline_source_queue=True)"})}),"\n",(0,r.jsxs)(n.p,{children:["This method runs the transport. For the ",(0,r.jsx)(n.code,{children:"DailyTransport"}),", that includes joining the Daily room and setting up audio/video send and receive, depending on what you've configured."]}),"\n",(0,r.jsxs)(n.p,{children:["This method also accepts a ",(0,r.jsx)(n.code,{children:"pipeline"})," argument. If you include a pipeline, the transport will run and manage that ",(0,r.jsx)(n.a,{href:"../pipelines",children:"Pipeline"})," for you. That includes connecting the pipeline's source and sink to the transport's send and receive queues. It will also start and stop your pipeline when the transport starts and stops."]}),"\n",(0,r.jsxs)(n.p,{children:["Your app will almost always include some form of ",(0,r.jsx)(n.code,{children:"await transport.run()"}),", usually ",(0,r.jsx)(n.code,{children:"await transport.run(pipeline)"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"transportrun_pipeline",children:"transport.run_pipeline()"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"async def run_pipeline(pipeline: Pipeline, override_pipeline_source_queue=True):\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This method connects the pipeline's source and sink to the transport's send and receive queues, but it doesn't manage the pipeline's lifecycle. You'll need to ",(0,r.jsx)(n.code,{children:"await transport.run_pipeline(pipeline)"})," separately from ",(0,r.jsx)(n.code,{children:"await transport.run()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"override_pipeline_source_queue"})," property is used for a few things internally."]}),"\n",(0,r.jsx)(n.h3,{id:"transportrun_interruptible_pipeline",children:"transport.run_interruptible_pipeline()"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"transport.run_interruptible_pipeline(\n    pipeline: Pipeline,\n    pre_processor: FrameProcessor | None = None,\n    post_processor: FrameProcessor | None = None,\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This method runs the pipeline connected to the transport's queues, but it runs it inside a cancelable ",(0,r.jsx)(n.code,{children:"asyncio.task()"}),". If the transport detects that the user starts speaking (which generates a ",(0,r.jsx)(n.code,{children:"UserStartedSpeaking"})," frame), the transport will cancel the currently executing ",(0,r.jsx)(n.code,{children:"asyncio.task()"}),", empty all the frames in the transport's send queue, and start a new task."]}),"\n",(0,r.jsx)(n.p,{children:"The end result of this is that you can run the pipeline, and anytime the user speaks, the bot will stop what it's doing and start listening to the user."}),"\n",(0,r.jsxs)(n.p,{children:["Typically, you'll want to create your pipeline such that it expects to receive and accumulate ",(0,r.jsx)(n.code,{children:"TranscriptionFrame"}),"s from the user, and start generating a response as soon as it receives a ",(0,r.jsx)(n.code,{children:"UserStoppedSpeakingFrame"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This method also accepts two optional services as ",(0,r.jsx)(n.code,{children:"pre_processor"})," and ",(0,r.jsx)(n.code,{children:"post_processor"}),". As it turns out, ",(0,r.jsx)(n.code,{children:"pre_processor"})," doesn't do anything special, so you can probably ignore it."]}),"\n",(0,r.jsxs)(n.p,{children:["But ",(0,r.jsx)(n.code,{children:"post_processor"})," is a bit different. As the transport runs, it consumes the frames coming out of the pipeline: Displaying ",(0,r.jsx)(n.code,{children:"ImageFrame"}),"s as video, playing ",(0,r.jsx)(n.code,{children:"AudioFrame"}),"s as audio, etc. But when running an interruptible pipeline, the transport will send each frame through the ",(0,r.jsx)(n.code,{children:"post_processor"})," ",(0,r.jsx)(n.em,{children:"after"})," it finishes doing whatever it's supposed to with that frame. More specifically, each ",(0,r.jsx)(n.code,{children:"AudioFrame"})," goes to the ",(0,r.jsx)(n.code,{children:"post_processor"})," ",(0,r.jsx)(n.em,{children:"after it has been successfully played"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If the pipeline gets interrupted, the contents of the transport's output queue get dumped, so none of those frames go through the ",(0,r.jsx)(n.code,{children:"post_processor"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["By convention, immediately after sending ",(0,r.jsx)(n.code,{children:"AudioFrame"}),"s with generated speech, ",(0,r.jsx)(n.a,{href:"../services/tts-service",children:"text-to-speech services"})," send a ",(0,r.jsx)(n.code,{children:"TextFrame"})," with the text of that speech through the pipeline. So if you put an ",(0,r.jsx)(n.code,{children:"LLMContextAggregator"})," in the ",(0,r.jsx)(n.code,{children:"post_processor"})," of an interruptible pipeline, you can ensure that the bot's context will only contain sentences ",(0,r.jsx)(n.em,{children:"it actually said to the user"}),". If a bot generates an 8-sentence response, but the user interrupts the bot in the middle of the 4th sentence, the context will only contain the first three sentences."]}),"\n",(0,r.jsx)(n.p,{children:"This method does not manage the pipeline lifecycle. You'll still need to do something like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"asyncio.gather(transport.run(), transport.run_interruptible_pipeline(pipeline))\n"})}),"\n",(0,r.jsx)(n.h2,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,r.jsxs)(n.p,{children:["(In order to keep the documentation a bit more readable, some of the functionality described here actually comes from a ",(0,r.jsx)(n.code,{children:"BaseTransport"})," class.)"]}),"\n",(0,r.jsx)(n.h3,{id:"send_app_message",children:(0,r.jsx)(n.code,{children:"send_app_message"})}),"\n",(0,r.jsxs)(n.p,{children:["Calls daily-python's ",(0,r.jsx)(n.a,{href:"https://reference-python.daily.co/api_reference.html#daily.CallClient.send_app_message",children:(0,r.jsx)(n.code,{children:"send_app_message"})})," function."]}),"\n",(0,r.jsx)(n.h3,{id:"dialout",children:(0,r.jsx)(n.code,{children:"dialout"})}),"\n",(0,r.jsxs)(n.p,{children:["Calls ",(0,r.jsx)(n.a,{href:"https://reference-python.daily.co/api_reference.html#daily.CallClient.start_dialout",children:(0,r.jsx)(n.code,{children:"start_dialout"})})," in daily-python, which can be used to call SIP or PSTN phone numbers. See the ",(0,r.jsx)(n.a,{href:"https://docs.daily.co/guides/products/dial-in-dial-out#main",children:"Daily docs"})," for more information."]}),"\n",(0,r.jsx)(n.h3,{id:"start_recording",children:(0,r.jsx)(n.code,{children:"start_recording"})}),"\n",(0,r.jsxs)(n.p,{children:["Starts a recording of the Daily room. See the ",(0,r.jsx)(n.a,{href:"https://docs.daily.co/reference/rest-api/rooms/recordings/start",children:"Daily docs"})," for more information."]}),"\n",(0,r.jsx)(n.h3,{id:"say",children:(0,r.jsx)(n.code,{children:"say"})}),"\n",(0,r.jsx)(n.p,{children:"This is a convenience method for generating text-to-speech from a given sentence. It bypasses any running pipelines and just sends the sound directly to the transport."}),"\n",(0,r.jsxs)(n.h3,{id:"stop-and-stop_when_done",children:[(0,r.jsx)(n.code,{children:"stop"})," and ",(0,r.jsx)(n.code,{children:"stop_when_done"})]}),"\n",(0,r.jsxs)(n.p,{children:["Functions for stopping a running transport. You probably don't need to call these directly; instead, sending an ",(0,r.jsx)(n.code,{children:"EndFrame"})," though your pipeline should stop everything."]}),"\n",(0,r.jsx)(n.h2,{id:"frame-behaviors",children:"Frame Behaviors"}),"\n",(0,r.jsxs)(n.p,{children:["Here's a list of different kinds of frames, and how the ",(0,r.jsx)(n.code,{children:"DailyTransport"})," handles them:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AudioFrame"}),": The transport will break the audio data into ~0.5s chunks and play them using ",(0,r.jsx)(n.code,{children:"daily-python"}),". The audio playback is synchronous in the transport's thread, which means that if the transport's queue contains several ",(0,r.jsx)(n.code,{children:"AudioFrame"}),"s followed by an ",(0,r.jsx)(n.code,{children:"ImageFrame"}),", the ",(0,r.jsx)(n.code,{children:"ImageFrame"})," won't get handled until ",(0,r.jsx)(n.em,{children:"playback of"})," the ",(0,r.jsx)(n.code,{children:"AudioFrame"}),"s is completed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ImageFrame"}),": When the transport receives an ",(0,r.jsx)(n.code,{children:"ImageFrame"}),", it will display that image in the bot's webcam video inside the Daily call. That image will stay set and appear on screen until another ",(0,r.jsx)(n.code,{children:"ImageFrame"})," is received."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SpriteFrame"}),": These frames contain a sequence of images. When the transport receives a ",(0,r.jsx)(n.code,{children:"SpriteFrame"}),", it will loop those frames in the bot's webcam video at the configured frame rate of the transport until it receives another ",(0,r.jsx)(n.code,{children:"SpriteFrame"})," or ",(0,r.jsx)(n.code,{children:"ImageFrame"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"UserImageRequestFrame"}),": If the transport's ",(0,r.jsx)(n.code,{children:"video_rendering_enabled"})," property is set to ",(0,r.jsx)(n.code,{children:"True"}),", when it receives a ",(0,r.jsx)(n.code,{children:"UserImageRequestFrame"}),", it will grab a frame from one or all participants' cameras and put those frames into the pipeline as ",(0,r.jsx)(n.code,{children:"UserImageFrame"}),"s"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SendAppMessageFrame"}),": If a ",(0,r.jsx)(n.code,{children:"DailyTransport"})," receives this frame, it will use ",(0,r.jsx)(n.code,{children:"send_app_message()"})," from daily-python to send a message to other call participants."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);