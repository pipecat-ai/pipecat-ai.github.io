"use strict";(self.webpackChunkpipecat_docs=self.webpackChunkpipecat_docs||[]).push([[274],{3366:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=n(4848),r=n(8453);const s={},o="LLMService (LLM Completion)",a={id:"api-reference/services/llm-service",title:"LLMService (LLM Completion)",description:"Frame Types",source:"@site/docs/api-reference/services/llm-service.md",sourceDirName:"api-reference/services",slug:"/api-reference/services/llm-service",permalink:"/docs/api-reference/services/llm-service",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-reference/services/llm-service.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ImageGenService (Image Generation)",permalink:"/docs/api-reference/services/image-gen-service"},next:{title:"STTService (Speech-To-Text)",permalink:"/docs/api-reference/services/stt-service"}},c={},l=[{value:"Frame Types",id:"frame-types",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Function Calling",id:"function-calling",level:2},{value:"Function callback return types",id:"function-callback-return-types",level:3},{value:"LLM Context",id:"llm-context",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"llmservice-llm-completion",children:"LLMService (LLM Completion)"}),"\n",(0,i.jsx)(t.h2,{id:"frame-types",children:"Frame Types"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Input:"})," ",(0,i.jsx)(t.code,{children:"LLMMessagesFrame"}),", or ",(0,i.jsx)(t.code,{children:"OpenAILLMContextFrame"})," for OpenAI-compatible LLM services"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Output:"})," LLM services yield these frames in this order for chat completions:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"LLMResponseStartFrame"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TextFrame"}),"s. Some services (like GPT-4) stream responses one word (token) at a time. Others, like Groq, will include the entire response in a single TextFrame."]}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"LLMResponseEndFrame"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"If the LLM is completing a function call instead of a chat response, it will yield these frames:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"LLMResponseStartFrame"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"LLMFunctionStartFrame"})," with the name of the function being called"]}),"\n",(0,i.jsxs)(t.li,{children:["A single ",(0,i.jsx)(t.code,{children:"LLMFunctionCallFrame"})," with the function name and arguments. Even if the service itself streams responses, the LLMService will aggregate them all together and yield a single ",(0,i.jsx)(t.code,{children:"LLMFunctionCallFrame"}),"."]}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"LLMResponseEndFrame"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(t.p,{children:"Each LLM service initializer takes a slightly different parameter set. Some allow you to specify a model. Most require an API key."}),"\n",(0,i.jsx)(t.h2,{id:"function-calling",children:"Function Calling"}),"\n",(0,i.jsxs)(t.p,{children:["Some services, such as OpenAI, support ",(0,i.jsx)(t.a,{href:"https://platform.openai.com/docs/guides/function-calling",children:"function calling"}),". You may have heard this or similar approaches also called Retrieval Augmented Generation, or RAG. This enables an LLM to query external services to get more information in response to user input."]}),"\n",(0,i.jsx)(t.p,{children:"A common example case is getting the current weather. At a high level, the process looks like this:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["As part of the context passed to the LLM, you include a list of functions available to the LLM. In this case, you'd specify a function named ",(0,i.jsx)(t.code,{children:"get_current_weather"}),", which accepts a ",(0,i.jsx)(t.code,{children:"location"})," parameter."]}),"\n",(0,i.jsxs)(t.li,{children:["The user talks to the LLM as usual, adding ",(0,i.jsx)(t.code,{children:"user"})," and ",(0,i.jsx)(t.code,{children:"assistant"})," messages to the stored context."]}),"\n",(0,i.jsxs)(t.li,{children:['The user asks a question like "What\'s the weather going to be in San Diego tomorrow?" The LLM recognizes it needs to use the ',(0,i.jsx)(t.code,{children:"get_current_weather"})," function to answer this question, so instead of returning a response to the user, it returns a ",(0,i.jsx)(t.code,{children:"tool_call"}),", asking to call the ",(0,i.jsx)(t.code,{children:"get_current_weather"})," function with a ",(0,i.jsx)(t.code,{children:"location"})," parameter of ",(0,i.jsx)(t.code,{children:"San Diego, CA"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Your app actually calls some kind of ",(0,i.jsx)(t.code,{children:"getWeather()"})," function that talks to an API and gets the weather, and then adds the resulting data to the bot's stored context as a ",(0,i.jsx)(t.code,{children:"function_response"})," message."]}),"\n",(0,i.jsx)(t.li,{children:"Your app re-prompts the LLM to generate another completion using the shared context. The LLM sees that the last few messages in the context include a question from the user about the weather, then the generated function call request, then the resulting data. The LLM then generates an actual chat response to the user based on the data returned from the function call."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This flow is fairly complicated, but Pipecat makes it a lot easier to work with by handling the context management and re-prompting for you. You'll still need to define the functions the LLM can use in OpenAI's JSON format. But once you've done that, you can call ",(0,i.jsx)(t.code,{children:"register_function"})," on your ",(0,i.jsx)(t.code,{children:"OpenAILLMService"})," instance to specify a callback for that function. It looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'\ntools = [\n    ChatCompletionToolParam(\n        type="function",\n        function={\n            "name": "get_current_weather",\n            "description": "Get the current weather",\n            "parameters": {\n                (...)\n            },\n        })]\n\n# (...)\n\nllm = OpenAILLMService(\n    api_key=os.getenv("OPENAI_API_KEY"),\n    model="gpt-4o")\n\nasync def fetch_weather_from_api(llm, args):\n    return ({"conditions": "nice", "temperature": "75"})\n\nllm.register_function("get_current_weather", fetch_weather_from_api)\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"register_function"})," function also has a ",(0,i.jsx)(t.code,{children:"start_callback"})," property that accepts a different callback function to call when the LLM first receives a function name. Sometimes it can take a bit of time for the LLM to stream the full function call body back, so this hook is a convenient place to put a small 'ding' sound effect indicating the LLM is 'working', or a short text response like \"let me think\" that will get converted to speech later. Pipecat ignores anything returned from the ",(0,i.jsx)(t.code,{children:"start_callback"}),". There are several examples of start callbacks in the patient-intake example."]}),"\n",(0,i.jsxs)(t.p,{children:["Your callback also receives an ",(0,i.jsx)(t.code,{children:"llm"})," parameter, which is the llm instance inside the running pipeline. You can use that to call ",(0,i.jsx)(t.code,{children:"llm.process_frame"})," to re-prompt it yourself. You can also do other things, like calling ",(0,i.jsx)(t.code,{children:"llm.push_frame(AudioRawFrame())"})," to play a sound effect. (The LLM service will just push that frame to the next processor down the pipeline, but it's the only 'hook' you have into the pipeline from inside the callback.)"]}),"\n",(0,i.jsxs)(t.p,{children:["By specifying a callback like this, Pipecat will handle everything for you. If the user asks for the weather and the LLM requests to call the ",(0,i.jsx)(t.code,{children:"get_current_weather"})," function, Pipecat will call your callback with the parameters from the LLM, format the return data correctly for the context, and re-prompt the LLM to generate a chat response. You can see this in action in the foundational example ",(0,i.jsx)(t.code,{children:"14-function-calling.py"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"function-callback-return-types",children:"Function callback return types"}),"\n",(0,i.jsx)(t.p,{children:"You can return three types of data from your callback to control how Pipecat behaves."}),"\n",(0,i.jsxs)(t.p,{children:["If you return a ",(0,i.jsx)(t.code,{children:"dict"})," like in the example above, Pipecat will presume it's the data for the requested function call. It will append the function call request and result to the shared context object, and re-prompt the LLM for a chat response. This is almost always what you want. See ",(0,i.jsx)(t.code,{children:"foundational/14-function-calling.py"})," to see this in action."]}),"\n",(0,i.jsxs)(t.p,{children:["If you return a ",(0,i.jsx)(t.code,{children:"list"})," containing ",(0,i.jsx)(t.code,{children:"dict"}),"s that look like LLM messages array entries (containing ",(0,i.jsx)(t.code,{children:"role"})," and ",(0,i.jsx)(t.code,{children:"content"})," properties), Pipecat will insert those into the shared context ",(0,i.jsx)(t.em,{children:"instead"})," of the function call and response, and then re-prompt the LLM. This can be useful if you're changing what functions are available to the LLM throughout the conversation. See ",(0,i.jsx)(t.code,{children:"patient-intake/bot.py"}),", specifically the ",(0,i.jsx)(t.code,{children:"verify_birthday"})," function, to see this in use."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, if you return ",(0,i.jsx)(t.code,{children:"None"})," from your callback, Pipecat won't do anything. It won't add anything to the context, and it won't re-prompt for you. You can do some or all of those things inside the callback directly if you want. Take a look at the ",(0,i.jsx)(t.code,{children:"save-data"})," callback in patient-intake to see how this works."]}),"\n",(0,i.jsx)(t.h2,{id:"llm-context",children:"LLM Context"}),"\n",(0,i.jsxs)(t.p,{children:["LLM services do not keep their own history. It's up to you to build your own ",(0,i.jsx)(t.code,{children:"messages"})," object to pass into the LLM service as a ",(0,i.jsx)(t.code,{children:"OpenAILLMContextFrame"})," or ",(0,i.jsx)(t.code,{children:"LLMMessagesFrame"}),". Fortunately, there are other tools in the framework to help with this. Take a look at ",(0,i.jsx)(t.a,{href:"utilities#aggregators",children:"the Aggregators section of the Utilities docs"})," to learn more."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);